package com.szlazakm.safechat.utils.auth

import com.szlazakm.safechat.utils.auth.ecc.AuthMessageHelper
import com.szlazakm.safechat.utils.auth.ecc.EccKeyHelper
import com.szlazakm.safechat.utils.auth.utils.Decoder
import com.szlazakm.safechat.utils.auth.utils.Encoder
import kotlinx.coroutines.test.runTest
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.junit.Before
import org.junit.Test
import java.security.Security
import java.time.Instant

class PenTestHelper {

    @Before
    fun setUp() {

        Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME)
        Security.insertProviderAt(BouncyCastleProvider(), 1)

    }

    @Test
    fun shouldEncryptAndDecryptInitialMessage() {

        val eccKeyPair = EccKeyHelper.generateKeyPair()

        println("Private key: " + Encoder.encode(eccKeyPair.privateKey))
        println("Public key: " + Encoder.encode(eccKeyPair.publicKey))
    }

    @Test
    fun generateNonce() {
        val nonce = AuthMessageHelper.generateNonce()
        println("Nonce: " + Encoder.encode(nonce))
    }

    @Test
    fun generateSignature() {

        val eccKeyPair = EccKeyHelper.generateKeyPair()

        val nonce =  AuthMessageHelper.generateNonce()
        val instant = Instant.now().epochSecond.toString()
        val privateKeyBytes = eccKeyPair.privateKey
        val dataToSign = nonce.plus(Decoder.decode(instant))
        val signature = AuthMessageHelper.generateSignature(
            privateKeyBytes,
            dataToSign
        )

        println("Public key: " + Encoder.encode(eccKeyPair.publicKey))
        println("Nonce: " + Encoder.encode(nonce))
        println("Instant: $instant")
        println("Signature: " + Encoder.encode(signature))
    }

    fun ByteArray.toHex(): String = joinToString(separator = "") { eachByte -> "%02x".format(eachByte) }
}